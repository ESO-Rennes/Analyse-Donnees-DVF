---
title: "DVF Script 3"
author: "[Boris Mericskay](https://perso.univ-rennes2.fr/boris.mericskay) et [Florent
  Demoraes](https://perso.univ-rennes2.fr/florent.demoraes)"
date: "02/07/2021 - Mise à jour 11/06/2025"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true
  word_document:
    toc: true
    number_sections: true
  pdf_document:
    toc: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = 'C:/DVF/SIGAT')
```

# LES DONNÉES DVF EN CARTES POUR SAISIR LES GRANDES TENDANCES SPATIALES DE L'IMMOBILIER

Ce script décrit plusieurs fonctions de manipulation de la dimension spatiale des données DVF. Il propose aussi plusieurs formes de représentation cartographique de ces données à une échelle régionale (Bretagne).

## Chargement des packages nécessaires

```{r loading package, warning=FALSE, message = FALSE, error=FALSE, echo=TRUE}
library(tidyverse) # Manipulation de données
library(sf) # Manipulation de données spatiales
library(mapsf) # Cartographie thématique
library(spdep) # pour calculer l'auto-corrélation spatiale
library(geoR) # pour calculer le semi-variogramme empirique
library(spatstat) # pour produire des surfaces lissées
library(terra) # pour le traitement de données raster
library(cartogramR) # pour créer des cartogrammes contigus
library(rmapshaper) # pour généraliser les contours
library(cluster) # CAH
library(data.table) # pour manipuler des tables volumineuses et réaliser des agrégations avec une performance accrue
library(future.apply) # pour paralléliser les traitements
library(fs)  # pour la gestion des fichiers temporaires
library(stars) # pour convertir un objet sf volumineux très rapidement en objet raster
library(tanaka) # pour élaborer des cartes selon la méthode des contours de relief
library(linemap) # pour élaborer des cartes en stalagmites avec un figuré en lignes de crête
```

## Import du jeu de données brut

```{r Import donnees}
# import du fichier csv avec la fonction fastread du package data.table
DVFOK <- fread("DVFOK.csv") 
```

## Création d'un semis de points correspondant aux mutations et reprojection

### Transformer le tableau des mutations en couche spatiale (objet sf) à partir des coordonnées XY

```{r creation objet spatial}
DVFgeo <- st_as_sf(DVFOK, coords = c("longitude","latitude"), crs = 4326)
plot(st_geometry(DVFgeo), pch = ".", cex = 0.01)
```

### Reprojeter la couche des mutations DVF en Lambert 93

```{r reprojection}
DVFgeo <- st_transform(DVFgeo, 2154)
```

### Exporter le semis de points des mutations au format geopackage (pour une utilisation dans un SIG par exemple) en utilisant une parallélisation

```{r export gpkg DVFgeo avec parallelisation, eval=FALSE, message=FALSE, warning=FALSE}
# pour supprimer le fichier s'il existe déjà
unlink("Resultats/Mutations_Bzh.gpkg")

# Créer un plan de calcul parallèle (fonction du package future.apply) pour accélérer l'export
plan(multisession)

# Calcul des indices pour partitionner l'objet sf en n sous-ensembles
n <- 10  # Nombre de sous-ensembles souhaités
indices <- cut(seq_len(nrow(DVFgeo)), breaks = n, labels = FALSE)

# Partitionnement de l'objet sf avec les indices créés
split_sf <- split(DVFgeo, indices)

# Définir le nom des fichiers temporaires pour chaque sous-ensemble et leur chemin
temp_files <- paste0(tempfile(), "_", seq_along(split_sf), ".gpkg")

# Paralléliser l'écriture des sous-ensembles dans des fichiers temporaires
future_lapply(seq_along(split_sf), function(i) {
  st_write(split_sf[[i]], temp_files[i], append = TRUE, quiet = TRUE)
})

# Assembler tous les fichiers temporaires en un seul fichier final
output_file <- "Resultats/Mutations_Bzh.gpkg"
for (temp_file in temp_files) {
  # Lire chaque sous-ensemble préalablement enregistré
  temp_data <- st_read(temp_file, quiet = TRUE)
  
  # Écrire dans le fichier final en ajoutant les lignes de chaque fichier temporaire
  st_write(temp_data, output_file, append = TRUE, quiet = TRUE)
}

# Supprimer les fichiers temporaires
file_delete(temp_files)
```

## Ajout de couches géographiques externes pour les analyses/cartes

### Importer la couche des départements et la reprojeter en Lambert 93

```{r import dpts, echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}
departements <- st_read("DEPARTEMENT.shp") # Source : Admin Express IGN (France entière)
departements <- st_transform(departements, 2154)
```

### Importer la couche des communes de Bretagne

```{r import communes}
Communes <- st_read("Communes.shp") # source : Admin Express IGN (Bretagne)
```

### Fusion des communes pour récuperer les contours des départements bretons

```{r fusion communes}
depBZH <- Communes %>% group_by(INSEE_DEP) %>% summarize()
plot(depBZH["INSEE_DEP"])
```

## Agrégations spatiales

### Dénombrement des mutations par commune (jointure spatiale et comptage)

```{r calcul nb mutations par commune}
Communes <- Communes %>% mutate(NbMutations = lengths(st_intersects(Communes, DVFgeo)))
sum(Communes$NbMutations) # nb total de mutations
```

### Carte du nombre de mutations par commune

```{r Carte du nombre de mutations par commune, message=FALSE,warning=FALSE}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# sélection des communes dont le nom sera affiché sur la carte
liste_noms <- c("Rennes", "Redon", "Vannes", "Lorient", "Quimper", "Brest", "Morlaix", "Lannion", "Saint-Brieuc", "Saint-Malo")
Selection_Communes <- Communes[which(Communes$NOM_COM %in% liste_noms), ]

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Ajout des departements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Affichage des symboles proportionnels (nombre de mutations)
mf_map(x = Communes,
       type = "prop",
          var = "NbMutations", # variable à cartographier
          col = "#e5478e", # couleur des cercles
          border = "white",  # couleur du contour des cercles
          inches = 0.2, # taille du cercle max
          lwd = 0.01, # épaisseur du contour des cercles
          leg_title = "Nombre de mutations \nDVF par commune")

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
mf_layout(title = "Nombre de mutations par commune en Bretagne (2014-2019)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Dénombrement du nombre de mutations de maisons et d'appartements par commune

```{r calcul nb maisons et appts par commune}
Maisons <- DVFgeo %>% filter(type == 'Maison')
Appartements <- DVFgeo %>% filter(type == "Appartement")
Communes <- Communes %>% mutate(NbMaisons = lengths(st_intersects(Communes, Maisons))) %>% mutate(NbAppart = lengths(st_intersects(Communes, Appartements)))
```

### Carte du nombre de ventes de maisons par commune

```{r Carte ventes de maisons par commune, message=FALSE}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Ajout des departements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Affichage des symboles proportionnels (nombre de mutations de maisons)
mf_map(x = Communes,
       type = "prop",
          var = "NbMaisons", # variable à cartographier
          col = "#2ECC40", # couleur des cercles
          border = "white",  # couleur du contour des cercles
          inches = 0.15, # taille du cercle max
          lwd = 0.01, # épaisseur du contour des cercles
          leg_title = "Ventes de maisons \npar commune")

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
mf_layout(title = "Nombre de ventes de maisons par commune en Bretagne (2014-2019)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Carte du nombre de ventes d'appartements par commune

```{r Carte ventes appartements par commune, message = FALSE}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Ajout des departements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Affichage des symboles proportionnels (nombre de mutations d'appartements)
mf_map(x = Communes,
       type = "prop",
          var = "NbAppart", # variable à cartographier
          col = "#F012BE", # couleur des cercles
          border = "white",  # couleur du contour des cercles
          inches = 0.2, # taille du cercle max
          lwd = 0.01, # épaisseur du contour des cercles
          leg_title = "Ventes d'appartements \npar commune")

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
mf_layout(title = "Nombre de ventes d'appartements par commune en Bretagne (2014-2019)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Calcul du prix nominal moyen, du prix moyen au m² et de la surface moyenne par commune

```{r Calcul du prix nominal moyen, du prix moyen au m2 et de la surface moyenne par commune}
# pour récupérer l'id des communes sur chaque mutation
DVFgeo.tmp <- st_join(DVFgeo, Communes["INSEE_COM"])

# pour calculer le prix nominal moyen, le prix moyen au m2 et la surface moyenne des mutations par commune (on utilise ici le package data.table pour optimiser le temps de calcul)
setDT(DVFgeo.tmp)  # Convertir le dataframe en data.table
communes.enrichies <- DVFgeo.tmp[, .(Nb_Mutations = .N, 
                                     PrixMoyen = round(mean(prix)),
                                     Prixm2Moyen = round(mean(prixm2)),
                                     SurfaceMoyenne = round(mean(surface))),
                                 by = INSEE_COM]

# pour récupérer les nouvelles variables dans la couche des communes initiales
Communes <- merge(Communes, communes.enrichies, by = "INSEE_COM")
rm(communes.enrichies, DVFgeo.tmp)
```

### Carte du prix moyen au m² des mutations par commune

```{r Carte prix moyen au m2 des mutations par commune}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

mf_map(
  x = Communes,
  var = "Prixm2Moyen",
  type = "choro",
  breaks = c(300, 1000, 1500, 2000, 2500, 5000),
  pal = c("#1a9641", "#a6d96a", "#ffffbf", "#fdae61", "#d7191c"),
  lwd = 0.001,
  border = "grey90",
  leg_title = "Prix moyen/m² \n(Euros)", 
  leg_pos = "bottomleft",
  leg_box_border = "#B5D0D0",
  leg_no_data = "",
  col_na = NA,
  leg_val_rnd = 0,
  leg_title_cex = 0.6,
  leg_val_cex = 0.4,
  leg_size = 0.7,
  add = TRUE
)

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey20", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
mf_layout(title = "Prix moyen au m² des mutations, par commune en Bretagne (2014-2019)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Carte du prix nominal moyen des mutations par commune

```{r carte prix nominal moyen}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

options("scipen" = 100)  # permet de convertir les chiffres initialement sous forme d'exposants en chiffres décimaux standard (utile pour l'affichage des valeurs en légende)

mf_map(
  x = Communes,
  var = "PrixMoyen",
  type = "choro",
  breaks = c(40000, 100000, 140000, 160000, 200000, 500000),
  pal = c("#2166ac","#67a9cf", "#fddbc7","#f4a582","#ca0020"),
  lwd = 0.001,
  border = "grey90",
  leg_title = "Prix nominal \nmoyen (Euros)", 
  leg_pos = "bottomleft",
  leg_box_border = "#B5D0D0",
  leg_no_data = "",
  col_na = NA,
  leg_val_rnd = 0,
  leg_title_cex = 0.6,
  leg_val_cex = 0.4,
  leg_size = 0.7,
  add = TRUE
)

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey20", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
mf_layout(title = "Prix nominal moyen des mutations par commune en Bretagne (2014-2019)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Export des communes enrichies et des départements bretons au format geopackage (pour une utilisation dans un SIG par exemple)

```{r export gpkg 2, message=FALSE, warning=FALSE, echo=TRUE}
st_write(Communes, "CommunesBZHDVF.gpkg", append = FALSE)
st_write(depBZH, "DepartementsBZH.gpkg", append = FALSE)
```

### Partitionnement régulier de l'espace et calcul du prix moyen au m² dans ce découpage

#### Création d'un carroyage avec des mailles de 2 km de côté

```{r carroyage}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
opar <- par(mar = c(0, 0, 1.5, 0))

grille <- st_make_grid(
  Communes,
  cellsize = 2000, 
  crs = 2154,
  what = "polygons",
  square = TRUE)

# Création d'un identifiant unique par maille
grille <- st_as_sf(grille)
grille <- grille %>% mutate(IDOK = row_number())

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

plot(st_geometry(grille), border = "grey90", lwd = 0.01, lty = 3)
plot(st_geometry(depBZH), lwd = 1, border = "red", add = TRUE)

par(opar) # pour réinitialiser les paramètres de la fenêtre graphique
```

#### Calcul du nombre de mutations et du prix moyen au m² par maille

```{r calcul nb mutations et prix moyen par maille, warning=FALSE, message = FALSE, error=FALSE}
# pour récupérer l'id des mailles sur chaque mutation (jointure spatiale)
DVFgeobis <- st_join(DVFgeo, grille["IDOK"]) 

# pour calculer le nombre de mutations et leur prix moyen par maille (on utilise ici à nouveau le package data.table pour optimiser le temps de calcul)
setDT(DVFgeobis)  # Convertir votre dataframe en data.table
grille.enrichie <- DVFgeobis[, .(Nb_Mutations = .N, 
                                 prixm2moyen = round(mean(prixm2))), 
                             by = IDOK]

# jointure attributaire pour récupérer les résultats dans la grille sf
grillem2 <- merge(grille, grille.enrichie, by = "IDOK", all = TRUE) 
rm(DVFgeobis, grille.enrichie)
```

#### Carte du prix au m² moyen de l'immobilier par maille de 2km

```{r Carte du prix au m2 moyen de immobilier par maille}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = NA, xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

mf_map(
  x = grillem2,
  var = "prixm2moyen",
  type = "choro",
  breaks = c(300, 1000, 1500, 2000, 2500, 5000),
  pal = c("#1a9641", "#a6d96a", "#ffffbf", "#fdae61", "#d7191c"),
  lwd = 0.001,
  border = NA,
  leg_title = "Prix moyen/m² \n(Euros)", 
  leg_pos = "bottomleft",
  leg_box_border = "#B5D0D0",
  leg_no_data = "Aucune mutation",
  col_na = NA,
  leg_val_rnd = 0,
  leg_title_cex = 0.6,
  leg_val_cex = 0.4,
  leg_size = 0.7,
  add = TRUE
)

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey20", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
mf_layout(title = "Prix moyen au m² des mutations par maille de 2 km en Bretagne (2014-2019)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Export du carroyage au format geopackage

```{r export gpkg 3, message=FALSE, warning=FALSE, echo=TRUE}
st_write(grillem2, "grillem2.gpkg", append = FALSE) # pour une utilisation dans un SIG par exemple
```

## Lissage spatial

### Lissage spatial des prix de l'immobilier au m² calculés à partir des valeurs agrégées par commune

#### Calcul des distances au plus proche voisin et de l'auto-corrélation spatiale des prix au m²

```{r calcul dist ppv et autocorrelation spatiale 1, warning = FALSE}
# pour calculer les pseudo-centroides des communes (indispensable pour le calcul de la distance au plus proche voisin)
CommunesBZHDVFCentroids <- st_point_on_surface(Communes)

# Identification du plus proche voisin de chaque commune (fonction spdep)
listPPV <- knearneigh(CommunesBZHDVFCentroids, k = 1)

# pour convertir l'objet précédent (knn) en objet nb (fonction spdep)
PPV <- knn2nb(listPPV, row.names = CommunesBZHDVFCentroids$INSEE_COM) 

# pour connaître la distance qui sépare chaque point à son plus proche voisin
distPPV <- nbdists(PPV, CommunesBZHDVFCentroids) 

# Pour afficher un résumé statistique et l'histogramme des distances au plus proche voisin
print(as.data.frame(t(as.matrix(summary(unlist(distPPV))))))
hist(unlist(distPPV), breaks = 20,
     main = "Distance au plus proche voisin",
     col = "black", border = "white", xlab = "Distance", ylab = "Fréquence")

# pour convertir les communes en objet nb (indispensable pour le calcul de l'indice de Moran)
nbCom <- poly2nb(pl = Communes,
                 snap = 50,
                 queen = TRUE)

# pour identifier les communes sans voisins topologiques (regions with no links), c'est-à-dire les îles
summary(nbCom)

# création d'une liste des communes sans voisins qui correspondent aux îles (à partir de l'indice des lignes)
Iles <- c("14", "427", "488", "1020", "1036", "1037", "1038", "1039")

# suppression des îles sans quoi le calcul de l'indice de Moran n'est pas possible
CommunesBZHDVF <- Communes[which(!row.names(Communes) %in% Iles), ]

# pour reconvertir les communes (sans les îles) en objet nb
nbCom <- poly2nb(pl = CommunesBZHDVF,
                 snap = 50,
                 queen = TRUE)

#calcul du test de Moran
print(moran.test(CommunesBZHDVF$Prixm2Moyen, listw = nb2listw(nbCom)))
```

#### Calcul du semi-variogramme empirique des prix au m² pour déterminer le rayon de lissage

```{r semi-variogramme, warning = FALSE}
# pour calculer les pseudo-centroides des communes sans les îles (indispensable pour le calcul du semi-variogramme)
CommunesBZHDVFCentroids <- st_point_on_surface(CommunesBZHDVF)

# Extraction des coordonnées géographiques
coordinates <- st_coordinates(CommunesBZHDVFCentroids)

# pour créer un dataframe avec la structure attendue par le package geoR
CommunesBZHDVFCentroids.df <- data.frame(x = coordinates[, 1], y = coordinates[, 2], value = CommunesBZHDVFCentroids$Prixm2Moyen)

# pour convertir l'objet sf en objet geodata (format requis par le package geoR pour calculer le semi-variogramme)
CommunesBZHDVFCentroids.geodata <- as.geodata(CommunesBZHDVFCentroids.df)

# pour calculer le semi-variogramme empirique (fonction geoR)
vario.ex <- variog(CommunesBZHDVFCentroids.geodata, bin.cloud = TRUE, option = "bin")
plot(vario.ex, main = "Semi-variogramme du prix au m² de l'immobilier en fonction de la distance", cex.main = 1)
lines(vario.ex, type ="l", lty = 2, col="red")
```

#### Carte lissée des prix de l'immobilier au m² calculés à partir des valeurs agrégées par commune sur l'ensemble de la Bretagne

```{r Carte lissee des prix m2 agreges par commune, message=FALSE, warning=FALSE}
# pour définir le contour de la Bretagne comme emprise pour le lissage (sinon le lissage est calculé sur une fenêtre rectangulaire)
Emprise <- as.owin(st_geometry(CommunesBZHDVF))

# pour créer un objet ppp (format spatstat) et y intégrer dedans l'emprise et les valeurs à lisser (prix moyen au m²)
CommunesBZHDVF.ppp <- ppp(x = coordinates[, 1], y = coordinates[, 2], window = Emprise, marks = CommunesBZHDVFCentroids$Prixm2Moyen)

# pour calculer la surface lissée (rayon lissage : 5 km et résolution spatiale de l'image : 10 ha) --> calcul long
cartelissee <- Smooth(CommunesBZHDVF.ppp, sigma = 5000, eps = sqrt(100000))

# Conversion de la surface lissée au format SpatRaster (package terra) et spécification du SRC
cartelissee.raster <- rast(cartelissee)
crs(cartelissee.raster) <- st_crs(Communes)$srid # pour redéclarer correctement le SRC

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 2))

# pour afficher la surface lissée et habiller la carte
# Calcul des seuils
bks <- unique(mf_get_breaks(values(cartelissee.raster), breaks = "q6"))

# Création d'une palette de couleurs (double gradation harmonique)
cols <- c("#2a9c4e", "#77c35c", "#c4e687", "#ffffc0", "#fec981", "#dc292c")

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Affichage de la surface lissée
plot(cartelissee.raster, breaks = bks, col = cols, add = T, legend = F)
plot(st_geometry(depBZH), border = "grey", lwd = 0.05, lty = 3, add = T)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

mf_legend(type = "choro",
          pos = "bottomleft",
          title = "Prix moyen \nau m²",
          val = bks,
          no_data = FALSE,
          val_rnd = -1,
          pal = cols,
          size = 0.7)

# Habillage de la carte
mf_layout(title = "Prix moyen au m² de l'immobilier par commune en Bretagne entre 2014 et 2019", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')
```

### Lissage spatial des prix de l'immobilier au m² calculés directement à partir des mutations immobilières, en mode raster 

#### Calcul des distances au plus proche voisin et de l'auto-corrélation spatiale des prix au m²

```{r calcul dist ppv et autocorrelation spatiale 2, warning=FALSE}

# Convertir l'objet sf en un objet spatstat de type ppp (utile pour calculer les distances au plus proche voisin et l'indice du plus proche voisin)
# Extraire les coordonnées des points
coords <- st_coordinates(DVFgeo)

# Définir l'emprise où se trouvent les points (fonction spatstat)
emprise <- as.owin(st_bbox(DVFgeo))

# Créer un objet ppp (format spatstat)
points_ppp <- ppp(coords[,1], coords[,2], window = emprise)

# Calculer la distance au plus proche voisin (PPV) pour chaque point (fonction spatstat) 
#--> extrêmement rapide par rapport aux alternatives st_nn du package nngeo et st_nearest_feature de sf
distances_au_PPV <- round(nndist(points_ppp))

# Histogramme des distances au plus proche voisin
hist(distances_au_PPV, nclass = 500,
     main = "Distance au plus proche voisin",
     col = "black", border = "white", xlab = "Distance", ylab = "Fréquence", xlim = c(0,400))

# Récupérer l'identifiant du plus proche voisin (PPV) de chaque point
id_PPV <- nnwhich(points_ppp)
df_PPV <- as.data.frame(id_PPV)
df_PPV$id <- as.integer(rownames(df_PPV))
df_PPV <- df_PPV[ , c("id", "id_PPV")] # pour réagencer les colonnes
View(df_PPV)

# Créer une liste dans laquelle chaque élément contient l'indice du PPV (format requis pour le calcul de l'indice de Moran avec le package spdep)
PPV <- split(df_PPV$id_PPV, df_PPV$id)

# Attribuer la classe "nb" à l'objet précédent (classe requise pour le calcul de l'indice de Moran avec le package spdep)
class(PPV) <- "nb"

# Afficher le résultat (optionnel)
#PPV

# calcul du test de Moran (fonction spdep)
print(moran.test(DVFgeo$prixm2, listw = nb2listw(PPV)))

```


#### Carte lissée des prix de l'immobilier au m² calculés directement à partir des mutations immobilières sur l'ensemble de la Bretagne, en mode raster

On choisit ici de lisser les valeurs des prix de l'immobilier au m² directement à partir des mutations. Le nombre de mutations et les prix sont dans un premier temps agrégés sur une grille régulière de points qui sera ensuite transformée en objet raster. C'est sur cet objet raster que le lissage sera appliqué. Cela permet un gain de temps considérable par rapport au lissage spatial sur un semis de points valués ppp proposé par spatstat.

```{r carte prix lisses calcules a partir mutations en mode raster, message=FALSE, warning=FALSE}

# création d'une grille sous forme de points (qui servira de support pour appliquer un premier niveau d'agrégation spatiale)
cellsize <- 500

grille <- st_make_grid(
  DVFgeo,
  cellsize = cellsize, 
  crs = 2154,
  what = "centers", # on choisit ici de créer uniquement un semis de points réguliers positionnés sur le centroïde de chaque maille (opération beaucoup plus rapide que la création de polygones carrés)
  square = TRUE)

# Conversion de la grille au format sf et création d'un identifiant unique par point de la grille
grille <- st_as_sf(grille)
grille$id_grid <- c(1:dim(grille)[1])

# création d'un df avec pour chaque mutation l'indice du point de la grille le plus proche et la distance qui l'en sépare

## Trouver les indices des plus proches voisins
indices <- st_nearest_feature(DVFgeo, grille)

## Calculer les distances uniquement pour les paires trouvées
distances <- st_distance(DVFgeo, grille[indices,], by_element = TRUE)
id_ppv <- data.frame(id_grid = indices, dist = as.numeric(distances))

# conversion des data.frames en objet data.table pour que les calculs soient rapides
id_ppv <- setDT(id_ppv)

DVFgeobis <- copy(DVFgeo) # La fonction 'copy' crée une véritable copie indépendante de l'objet. Sans cela, DVFgeobis <- DVFgeo ne crée qu'une référence à la même structure de données en mémoire.
setDT(DVFgeobis)

# jointure pour récupérer le prix au m² de chaque mutation
id_ppv <- cbind(id_ppv, DVFgeobis[, .(prixm2)])

# pour calculer le nombre de mutations et leur prix moyen pour chaque point de la grille qui est ressorti comme étant le plus proche voisin d'une mutation (agrégation avec la syntaxe data.table)
pts.grille.enrichie <- id_ppv[, .(Nb_Mutations = .N, 
                                  prixm2moyen = round(mean(prixm2))), 
                              by = id_grid]

# récupération des informations précédentes dans la grille complète
grille.enrichie <- merge(grille, pts.grille.enrichie, by = "id_grid", all.x = TRUE)

# création de la grille raster
# Créer une étendue englobant tous les points de la grille
bbox <- st_bbox(grille.enrichie)

# Créer une structure raster régulière sur cette étendue (fonction du package stars)
template_raster <- st_as_stars(st_bbox(bbox), dx = cellsize, dy = cellsize)

# Rasteriser l'objet grille.enrichie en utilisant cette structure (fonction du package stars))
grille_raster <- st_rasterize(grille.enrichie, template = template_raster)

# pour retirer la bande contenant les id
grille_raster$id_grid <- NULL

# Convertir en SpatRaster (fonction du package stars)
grille_spatraster <- as(grille_raster, "SpatRaster")

# affichage des deux bandes (optionnel)
plot(grille_spatraster, col = (hcl.colors("Inferno", n = 5, rev = TRUE)), axes = FALSE)

# Lissage des prix moyens au m² (méthode des noyaux, en mode raster)

# calcul de la matrice des poids des pixels qui va décroissant avec la distance et la fonction de lissage (fonction terra)
matrice_poids <- focalMat(x = grille_spatraster, d = 2000, type = "Gauss")

# lissage de la valeur des pixels
grille_lissee_prix_m2 <- focal(x = grille_spatraster$prixm2moyen, w = matrice_poids, fun = mean, na.rm = TRUE) 

# découpage du raster pour ne garder que la partie située sur l'emprise de la Bretagne
grille_lissee_prix_m2 <- mask(grille_lissee_prix_m2, depBZH)

# pour afficher la surface lissée et définir l'habillage de la carte
# Calcul des seuils
bks <- unique(mf_get_breaks(values(grille_lissee_prix_m2), breaks = "q6"))

# Création d'une palette de couleurs (double gradation harmonique)
cols <- c("#2a9c4e", "#77c35c", "#c4e687", "#ffffc0", "#fec981", "#dc292c")

# sélection des communes dont le nom sera affiché sur la carte
liste_noms <- c("Rennes", "Redon", "Vannes", "Lorient", "Quimper", "Brest", "Morlaix", "Lannion", "Saint-Brieuc", "Saint-Malo")
Selection_Communes <- Communes[which(Communes$NOM_COM %in% liste_noms), ]

#paramétrage de la fenêtre graphique
opar <- par(mar = c(0,0,1.5,0))

# Affichage des départements de la Bretagne et des départements limitrophes en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey80", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(depBZH)[1], st_bbox(depBZH)[3]), ylim = c(st_bbox(depBZH)[2], st_bbox(depBZH)[4]))

# Affichage de la surface lissée
plot(grille_lissee_prix_m2, breaks = bks, col = cols, legend = FALSE, axes = FALSE, add = TRUE)
plot(st_geometry(depBZH), border = "grey30", lwd = 0.2, lty = 3, add = T)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.6, pos = 3, font = 4, offset = 0.5)

# Habillage de la carte
mf_layout(title = "Prix moyen au m² de l'immobilier en Bretagne (2014-2023)", credits  = "", arrow = FALSE)

mf_arrow(pos = "topright")

mf_legend(type = "choro",
          pos = "bottomleft",
          title = "Prix moyen \nau m²",
          val = bks,
          no_data = FALSE,
          val_rnd = -1,
          pal = cols,
          size = 0.7)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')

# Ajout d'une indication sur la méthode de calcul en marge de la carte
mtext("Prix moyens calculés à partir des mutations\nagrégées par maille de 25 ha.", side = 3, line = -1.5, adj = 0.03, cex = 0.5)

par(opar) # pour réinitialiser les paramètres graphiques

```


#### Carte lissée des prix de l'immobilier au m² avec isolignes sur l'ensemble de la Bretagne (variante)

```{r carte prix lisses calcules a partir mutations en mode raster avec isolignes, message=FALSE, warning=FALSE}

# Pour rajouter des contours avec les valeurs sur les isolignes

#paramétrage de la fenêtre graphique
opar <- par(mar = c(0,0,1.5,0))

# Affichage des départements de la Bretagne et des départements limitrophes en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey80", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(depBZH)[1], st_bbox(depBZH)[3]), ylim = c(st_bbox(depBZH)[2], st_bbox(depBZH)[4]))

# Affichage de la surface lissée
plot(grille_lissee_prix_m2, breaks = bks, col = cols, legend = FALSE, axes = FALSE, add = TRUE)

# Affichage des isolignes avec leur valeur
contour(grille_lissee_prix_m2, lwd = 0.5, lty = 3, add = TRUE)

# Habillage de la carte
mf_layout(title = "Prix moyen au m² de l'immobilier en Bretagne (2014-2023)", credits  = "", arrow = FALSE)

mf_arrow(pos = "topright")

mf_legend(type = "choro",
          pos = "bottomleft",
          title = "Prix moyen \nau m²",
          val = bks,
          no_data = FALSE,
          val_rnd = -1,
          pal = cols,
          size = 0.7)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')

# Ajout d'une indication sur la méthode de calcul en marge de la carte
mtext("Prix moyens calculés à partir des mutations\nagrégées par maille de 25 ha.", side = 3, line = -1.5, adj = 0.03, cex = 0.5)

par(opar) # pour réinitialiser les paramètres graphiques


```

### Carte du volume des mutations sous forme de contour de relief (méthode de Tanaka)

```{r tanaka}
# lissage de la concentration des mutations par la méthode des noyaux (fonction terra)
grille_lissee <- focal(x = grille_spatraster$Nb_Mutations, w = matrice_poids, fun = sum, na.rm = TRUE) # calcul de la somme des mutations (calcul lissé)

# découpage du raster sur l'emprise de la Bretagne
grille_lissee <- mask(grille_lissee, depBZH)

# Histogramme et définition des seuils pour la discrétisation
hist(terra::values(grille_lissee), nclass = 100, xlim = c(0,40))
bks <- c(0:10,15,20,50,100,max(values(grille_lissee), na.rm = TRUE))

#paramétrage de la fenêtre graphique
opar <- par(mar = c(0,0,1.5,0), bg = "ivory2")

# définition d'une palette de couleurs
palette <- hcl.colors(n = length(bks)-1, palette = "RdYlBu", rev = TRUE)

#Affchage de la carte en contour de relief
tanaka(x = grille_lissee,
       breaks = bks,
       col = palette,
       shift = 500,
       mask = depBZH,
       legend.pos = NA)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.6, pos = 3, font = 4, offset = 0.5)

# Habillage de la carte
mf_layout(title = "Nombre de transactions immobilières en Bretagne entre 2014 et 2019", credits  = "")

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')

mf_legend(
  type = "choro",
  val = bks,
  pal = palette,
  title = "Nombre de\nmutations\npar maille\nde 25 ha.",
  pos = "bottomleft",
  size = 0.7,
  title_cex = 0.7
)
 
par(opar) # pour réinitialiser les paramètres graphiques
```

### Carte du volume des mutations sous forme de stalagmites

```{r linemap stalagmites}
#paramétrage de la fenêtre graphique
opar <- par(mar = c(0,0,1.5,0), bg = "ivory2")

#Affchage de la carte en stalagmites
linemap(grille_lissee,
        k = 550,
        col = "ivory1", 
        border = "ivory4", 
        lwd = 0.1)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, col = "red", bg = "white", r = 0.05, cex = 0.6, pos = 3, font = 4, offset = -1)

# Habillage de la carte
mf_layout(title = "Nombre de transactions immobilières par maille de 25 ha. en Bretagne (2014-2019)", credits  = "")

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')

# Ajout du max comme indication en marge de la carte
mtext(paste0("Max = ", round(max(values(grille_lissee), na.rm = TRUE)), " mutations"), side = 1, line = -2.5, adj = 0.03, cex = 0.5)

 
par(opar) # pour réinitialiser les paramètres graphiques
```

## Cartogramme et lissage spatial

### Création d'un objet correspondant aux EPCI bretons et agrégation des valeurs de l'immobilier

```{r creation EPCI}
# pour créer une couche des EPCI à partir des communes
EPCI.BZH <- Communes %>% group_by(CODE_EPCI) %>% summarize()

# pour récupérer l'id des EPCI sur chaque mutation
DVFgeo.enrichi <- st_join(DVFgeo, EPCI.BZH["CODE_EPCI"])

# pour calculer le nombre de mutations et leur prix moyen par EPCI (package data.table)
setDT(DVFgeo.enrichi)  # Convertir le dataframe en data.table
EPCI.enrichi <- DVFgeo.enrichi[, .(NbMutations = .N, 
                                   prixm2moyen = round(mean(prixm2))), 
                               by = CODE_EPCI]

# jointure attributaire pour récupérer les résultats dans l'objet sf EPCI
EPCI.BZH <- merge(EPCI.BZH, EPCI.enrichi, by = "CODE_EPCI", all = TRUE) 
rm(DVFgeo.enrichi, EPCI.enrichi)
```

### Création d'un cartogramme avec le nombre de mutations par EPCI

```{r affichage cartogramme simple}
# pour créer un cartogramme suivant le nombre de mutations par EPCI
EPCI.BZH.cartogram <- cartogramR(EPCI.BZH, count = "NbMutations")

# Pour déplacer les noms des étiquettes (nom des quelques communes choisies) en fonction de la déformation utilisée pour construire le cartogramme
Selection_Communes.deplacees <- warp_features(Selection_Communes, EPCI.BZH.cartogram)

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 3))

# pour afficher le cartogramme
plot(EPCI.BZH.cartogram, border = "grey95")

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes.deplacees, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# construction de la légende de la déformation
# Calculer la moyenne de NbMutations
moyenne <- mean(EPCI.BZH.cartogram$cartogram$NbMutations, na.rm = TRUE)

# Sélectionner l'unité spatiale dont la valeur de NbMutations est la plus proche de la moyenne
Unite_spatiale_legende <- EPCI.BZH.cartogram$cartogram[which.min(abs(EPCI.BZH.cartogram$cartogram$NbMutations - moyenne)), ]

# Choix de son emplacement à l'aide de la fonction grconvertX 
'Cette fonction permet de spécifier les coordonnées graphiques de R (de 0 à 1) où l’on souhaite placer notre légende de déformation et de les convertir dans le système de coordonnées de la carte (en mètres)'
Echelle_x <- grconvertX(c(0.15), from = "ndc", to = "user")
Echelle_y <- grconvertY(c(0.15), from = "ndc", to = "user")

# calcul du delta X et du delta Y (translation en mètres à appliquer aux sommets de l'unité spatiale choisie)
delta_x <- Echelle_x - st_geometry(st_centroid(Unite_spatiale_legende))[[1]][1]
delta_y <- Echelle_y - st_geometry(st_centroid(Unite_spatiale_legende))[[1]][2]

#translation de cette unité pour la positionner en marge de la carte à l'emplacement choisi
st_geometry(Unite_spatiale_legende)[[1]] <- st_geometry(Unite_spatiale_legende)[[1]] + st_point(c(delta_x, delta_y)) 

#ajout d'une étiquette dans la table attributaire
Unite_spatiale_legende$legend <- paste(Unite_spatiale_legende$NbMutations, "mutations", sep = "\n")

#affichage de la légende du cartogramme
plot(st_geometry(Unite_spatiale_legende), col = NA, border = "grey95", add = TRUE)
mf_label(Unite_spatiale_legende, "legend", halo = TRUE, cex = 0.4, offset = 0)


```

### Cartogramme montrant le nombre de mutations et les prix au m² de l'immobilier lissés

```{r deformation et carto surface lissee, message=FALSE, warning=FALSE}
# Calcul des seuils
bks <- unique(mf_get_breaks(values(grille_lissee_prix_m2), breaks = "q6"))

# classification de la surface lissée préalablement calculée
cartelissee.reclass <- classify(grille_lissee_prix_m2, bks, include.lowest = TRUE, brackets = TRUE)

# vectorisation de la surface reclassée
cartelissee.vecteur <- st_as_sf(as.polygons(cartelissee.reclass))

# Pour rogner légèrement cartelissee.vecteur (-3000 mètres) pour que l'emprise de cet objet soit comprise à l'intérieur de celle du cartogramme (opération à n'effectuer que si la commande suivante ne fonctionne pas)
# cartelissee.vecteur <- st_crop(cartelissee.vecteur, ext(as.sf(EPCI.BZH.cartogram))-3000)

# Pour déformer la surface lissée suivant les mêmes paramètres que ceux ayant servi à construire le cartogramme
cartelissee.vecteur.drapee <- warp_features(cartelissee.vecteur, EPCI.BZH.cartogram)

# pour généraliser les contours de cartelissee.vecteur.drapee (on garde 5% des sommets initiaux)
cartelissee.vecteur.drapee <- ms_simplify(cartelissee.vecteur.drapee, keep = 0.05, keep_shapes = TRUE)

# conversion de l'objet cartogram EPCI en objet sf
EPCI.BZH.cartogram.sf <- as.sf(EPCI.BZH.cartogram)

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.5, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

plot(cartelissee.vecteur.drapee, breaks = bks, border = NA, col = cols, add = TRUE)

mf_legend(
  type = 'choro',
  pos = "bottomleft",
  val = bks, 
  pal = cols,
  title = "Prix moyen \nau m² (Euros)",
  val_cex = 0.5,
  size = 0.7,
  no_data = FALSE,
  box_border = "white",
  val_rnd = -1,
)

# Habillage de la carte
mf_layout(title = "Prix au m² et mutations par EPCI en Bretagne (2014-2019)", credits  = "", arrow = TRUE, scale = FALSE)

mf_credits(txt = "Sources : IGN et DGFip \nDéformation des EPCI suivant le nombre de mutations", cex = 0.3, pos = 'bottomright')

plot(st_geometry(EPCI.BZH.cartogram.sf), border = "white", lwd = 1, add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

#affichage de la légende du cartogramme
plot(st_geometry(Unite_spatiale_legende), col = NA, border = "white", add = TRUE)
mf_label(Unite_spatiale_legende, "legend", cex = 0.4, offset = 0)

par(opar) # pour réinitialiser les paramètres graphiques
```

## Elaboration d'une typologie à partir d'indicateurs immobiliers et cartographie des sous-marchés associés

### Création d'un tableau avec les variables à soumettre à la CAH pour chacune des communes

```{r preparation donnees pour CAH}
CommunesDVFClassif1 <- as.data.frame(Communes) %>% select(INSEE_COM, NbMutations, PrixMoyen, Prixm2Moyen)
CommunesDVFClassif1 <- CommunesDVFClassif1 %>% na.omit()
CommunesDVFClassif <- CommunesDVFClassif1 %>% select(NbMutations, PrixMoyen, Prixm2Moyen)
```

### Centrage et réduction des variables

```{r centrage et reduction des variables}
CommunesDVFClassifscale <- scale(CommunesDVFClassif)
```

### Classification

```{r CAH}
CAHCommunes <- agnes(CommunesDVFClassifscale,
                     metric = "euclidean",
                     method = "ward")
```

### Graphiques des gains d'inertie inter-classe

```{r graphiques gains inertie}
sortedHeight <- sort(CAHCommunes$height, decreasing = TRUE)
relHeight <- sortedHeight / sum(sortedHeight) * 100
barplot(relHeight[1:30], names.arg = seq(1, 30, 1), col = "black", border = "white", xlab = "Noeuds", ylab = "Part de l'inertie totale (%)")
```

### Arbre hiérarchique

```{r arbre hierarchique}
dendroCSP <- as.dendrogram(CAHCommunes)
plot(dendroCSP, leaflab = "none")
```

### Partition (en n classes)

```{r partionnement en classes}
clusCSP <- cutree(CAHCommunes, k = 7)
CommunesCluster <- as.data.frame(CommunesDVFClassif1)
CommunesCluster$CLUSIMMO <- factor(clusCSP,
                                   levels = 1:7,
                                   labels = paste("CLUS", 1:7))
```

### Création d'un tableau caractérisant les groupes

```{r tableau synthese}
RecapCAHRegion <- CommunesCluster %>% group_by(CLUSIMMO) %>% summarise(
  Nbcommunes = n(), 
  NbMutationsmoyen = round(mean(NbMutations)), 
  Prixmoyen = round(mean(PrixMoyen)), 
  Prixm2moyen = round(mean(Prixm2Moyen)))
print(RecapCAHRegion)
```

### Graphique des variations à la moyenne

```{r Graphique variations a la moyenne, warning=FALSE, message = FALSE, error=FALSE}
SyntheseCAHRegion <- RecapCAHRegion %>% mutate(
  NbmutationBZH = mean(CommunesDVFClassif$NbMutations),
  SurfaceBZH = mean(CommunesDVFClassif$SurfaceMoyenne),
  PrixBZH = mean(CommunesDVFClassif$PrixMoyen),
  Prixm2BZH = mean(CommunesDVFClassif$Prixm2Moyen),
  NbMutations = (NbMutationsmoyen - NbmutationBZH) / NbmutationBZH * 100,
  Prix = (Prixmoyen- PrixBZH) / PrixBZH * 100,
  Prixm2 = (Prixm2moyen- Prixm2BZH) / Prixm2BZH * 100
)

SyntheseCAHRegion <- SyntheseCAHRegion %>% select(CLUSIMMO, Prix, Prixm2)
gather <- SyntheseCAHRegion %>% gather(key = variable, value = "value", Prix:Prixm2)
ggplot(gather, aes(x = variable, y = value, fill = CLUSIMMO)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(values = c("#416979","#f9c155","#39a699","#FF4136","#FF851B","#2cb1e3", "#1f78b4")) +
  ylab("Variation a la moyenne (%)") +
  theme_bw() +
  theme(legend.position = "none") +
  facet_wrap(~CLUSIMMO, ncol = 1)
```

### Représentation cartographique des classes issues de la CAH

```{r representation carto des classes}
CommunesDVFCAH <- merge(Communes, CommunesCluster, by = "INSEE_COM")
par(mar = c(0,0,0.9,0))

cols <- c("#416979","#f9c155","#39a699","#FF4136","#FF851B","#2cb1e3", "#1f78b4")

mf_map(
  type = 'typo',
  x = CommunesDVFCAH,
  var = "CLUSIMMO",
  pal = cols,
  border = NA,
  leg_pos = NA
  )

mf_legend(
  type = 'typo',
  pos = "bottomleft",
  val = unique(CommunesDVFCAH$CLUSIMMO),
  pal = cols,
  title = "Sous-marchés",
  val_cex = 0.35,
  size = 0.7,
  box_cex = c(1, 0.75),
  box_border = "white"
)

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "#000000", add = TRUE)

# Habillage de la carte
mf_layout(title = "Sous-marchés immobiliers issus de la CAH (Bretagne)", credits  = "", arrow = TRUE)

mf_credits(txt = "          IGN et DGFip, 2021", cex = 0.5, pos = 'rightbottom')

# Ajouter les étiquettes des communes sélectionnées plus haut
mf_label(Selection_Communes, var = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)
```

### Export des communes contenant la typologie issue de la CAH au format geopackage

```{r export commune en gpkg, message=FALSE, warning=FALSE}
st_write(CommunesDVFCAH, "CommunesBZHDVF.gpkg", append = FALSE) # pour une utilisation dans un SIG par exemple
```
