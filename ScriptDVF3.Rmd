---
title: 'DVF Script 3'
author: '[Boris Mericskay](https://perso.univ-rennes2.fr/boris.mericskay) et [Florent Demoraes](https://perso.univ-rennes2.fr/florent.demoraes)'
date: '02/07/2021 - Mise à jour 18/10/2023' 
output:
  html_document: 
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    number_sections: yes
  word_document:
    toc: yes
    number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = 'C:/DVF/SIGAT')
```

# LES DONNÉES DVF EN CARTES POUR SAISIR LES GRANDES TENDANCES SPATIALES DE L'IMMOBILIER

Ce script décrit plusieurs fonctions de manipulation de la dimension spatiale des données DVF. Il propose aussi plusieurs formes de représentation cartographique de ces données à une échelle régionale (Bretagne).

## Chargement des packages nécessaires

```{r loading package, warning=FALSE, message = FALSE, error=FALSE, echo=TRUE}
library(tidyverse) # Manipulation de données
library(sf) # Manipulation de données spatiales
library(cartography) # Cartographie thématique
library(spdep) # pour calculer l'auto-corrélation spatiale
library(geoR) # pour calculer le semi-variogramme empirique
library(spatstat) # pour produire des surfaces lissées
library(terra) # pour le traitement de données matricielles (raster)
library(cartogramR) # pour créer des cartogrammes contigus
library(rmapshaper) # pour généraliser les contours (simplification de la composante géométrique)
library(cluster) # CAH
library(data.table) # pour manipuler des tables et réaliser des agrégations
```

## Import du jeu de données brut

```{r Import donnees}
DVFOK <- read.csv("DVFOK.csv", encoding = "UTF-8")
```

## Création d'un semis de points correspondant aux mutations et reprojection

### Transformer le tableau des mutations en couche spatiale (objet sf) à partir des coordonnées XY

```{r creation objet spatial}
DVFgeo <- st_as_sf(DVFOK, coords = c("longitude","latitude"), crs = 4326)
plot(st_geometry(DVFgeo), pch = 3, cex = 0.1)
```

### Reprojeter la couche des mutations DVF en Lambert 93

```{r reprojection}
DVFgeo <- st_transform(DVFgeo, 2154)
```

### Exporter le semis de points des mutations au format geopackage (pour une utilisation dans un SIG par exemple)

```{r export gpkg DVFgeo, message=FALSE}
st_write(DVFgeo, "MutationsBZH.gpkg", append = FALSE)
```

## Ajout de couches géographiques externes pour les analyses/cartes

### Importer la couche des départements et la reprojeter en Lambert 93

```{r import dpts}
departements <- st_read("DEPARTEMENT.shp") # Source : Admin Express IGN (France entière)
departements <- st_transform(departements, 2154)
```

### Importer la couche des communes de Bretagne

```{r import communes}
Communes <- st_read("Communes.shp") # source : Admin Express IGN (Bretagne)
```

### Fusion des communes pour récuperer les contours des départements bretons

```{r fusion communes}
depBZH <- Communes %>% group_by(INSEE_DEP) %>% summarize()
plot(depBZH["INSEE_DEP"])
```

## Agrégations spatiales

### Dénombrement des mutations par commune (jointure spatiale et comptage)

```{r calcul nb mutations par commune}
Communes <- Communes %>% mutate(NbMutations = lengths(st_intersects(Communes, DVFgeo)))
sum(Communes$NbMutations) # nb total de mutations
```

### Carte du nombre de mutations par commune

```{r Carte du nombre de mutations par commune}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# sélection des communes dont le nom sera affiché sur la carte
liste_noms <- c("Rennes", "Redon", "Vannes", "Lorient", "Quimper", "Brest", "Morlaix", "Lannion", "Saint-Brieuc", "Saint-Malo")
Selection_Communes <- Communes[which(Communes$NOM_COM %in% liste_noms), ]

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Ajout des departements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Affichage des symboles proportionnels (nombre de mutations)
propSymbolsLayer(x = Communes, # appel du jeu de données
                 var = "NbMutations", # appel de la variable à cartographier
                 col = "#e5478e", # couleur des cercles
                 border = "#FFFFFF",  # couleur du contour des cercles
                 inches = 0.3, # taille des cercles
                 lwd = 0.01, # épaisseur du contour des cercles
                 fixmax = max(Communes$NbMutations),
                 legend.title.txt = "Nombre de mutations \nDVF par commune")

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
layoutLayer(title = "Nombre de mutations par commune en Bretagne (2014-2019)", source = "         IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")
```

### Dénombrement du nombre de mutations de maisons et d'appartements par commune

```{r calcul nb maisons et appts par commune}
Maisons <- DVFgeo %>% filter(type == 'Maison')
Appartements <- DVFgeo %>% filter(type == "Appartement")
Communes <- Communes %>% mutate(NbMaisons = lengths(st_intersects(Communes, Maisons))) %>% mutate(NbAppart = lengths(st_intersects(Communes, Appartements)))
```

### Carte du nombre de ventes de maisons par commune

```{r Carte ventes de maisons par commune}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Ajout des departements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Affichage des symboles proportionnels (nombre de mutations)
propSymbolsLayer(x = Communes, # appel du jeu de données
                 var = "NbMaisons", # appel de la variable à cartographier
                 col = "#2ECC40", # couleur des cercles
                 border = "#FFFFFF",  # couleur du contour des cercles
                 inches = 0.2, # taille des cercles
                 lwd = 0.01, # épaisseur du contour des cercles
                 fixmax = max(Communes$NbMaisons),
                 legend.title.txt = "Ventes de maisons \npar commune")

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
layoutLayer(title = "Nombre de ventes de maisons par commune en Bretagne (2014-2019)", source = "         IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")
```

### Carte du nombre de ventes d'appartements par commune

```{r Carte ventes appartements par commune}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Ajout des departements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Affichage des symboles proportionnels (nombre de mutations)
propSymbolsLayer(x = Communes, # appel du jeu de données
                 var = "NbAppart", # appel de la variable à cartographier
                 col = "#F012BE", # couleur des cercles
                 border = "#FFFFFF",  # couleur du contour des cercles
                 inches = 0.3, # taille des cercles
                 lwd = 0.01, # épaisseur du contour des cercles
                 fixmax = max(Communes$NbAppart),
                 legend.title.txt = "Ventes d'appartements \npar commune")

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)

# Habillage de la carte
layoutLayer(title = "Nombre de ventes d'appartements par commune en Bretagne (2014-2019)", source = "         IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")
```

### Calcul du prix nominal moyen, du prix moyen au m² et de la surface moyenne par commune

```{r Calcul du prix nominal moyen, du prix moyen au m2 et de la surface moyenne par commune}
# pour récupérer l'id des communes sur chaque mutation
DVFgeo.tmp <- st_join(DVFgeo, Communes["INSEE_COM"])

# pour calculer le prix nominal moyen, le prix moyen au m2 et la surface moyenne des mutations par commune (package data.table)
setDT(DVFgeo.tmp)  # Convertir votre dataframe en data.table
communes.enrichies <- DVFgeo.tmp[, .(Nb_Mutations = .N, 
                                     PrixMoyen = round(mean(prix)),
                                     Prixm2Moyen = round(mean(prixm2)),
                                     SurfaceMoyenne = round(mean(surface))),
                                 by = INSEE_COM]

# pour récupérer les nouvelles variables dans la couche des communes initiales
Communes <- merge(Communes, communes.enrichies, by = "INSEE_COM")
rm(communes.enrichies, DVFgeo.tmp)
```

### Carte du prix moyen au m² des mutations par commune

```{r Carte prix moyen au m2 des mutations par commune}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

choroLayer(
  x = Communes, 
  var = "Prixm2Moyen", 
  breaks = c(300, 1000, 1500, 2000, 2500, 5000),
  col = c("#1a9641", "#a6d96a", "#ffffbf", "#fdae61", "#d7191c"),
  lwd = 0.001,
  add = TRUE,
  legend.nodata = "",
  colNA = "#B5D0D0",
  border = "grey90",
  legend.pos = "bottomleft",
  legend.title.txt = "Prix moyen/m² (Euros)",
  legend.border = "#B5D0D0")

# Habillage de la carte
layoutLayer(title = "Prix moyen au m² des mutations, par commune en Bretagne (2014-2019)", source = "IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.7, pos = 3, font = 4, offset = 0)
```

### Carte du prix nominal moyen des mutations par commune

```{r carte prix nominal moyen}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

options("scipen" = 100)  # permet de convertir les chiffres initialement sous forme d'exposants en chiffres décimaux standard (utile pour l'affichage des valeurs en légende)

choroLayer(
  x = Communes, 
  var = "PrixMoyen", 
  breaks = c(40000, 100000, 140000, 160000, 200000, 500000),
  col = c("#2166ac","#67a9cf", "#fddbc7","#f4a582","#ca0020"),
  lwd = 0.001,
  add = TRUE,
  legend.nodata = "",
  colNA = "#B5D0D0",
  border = "grey90",
  legend.pos = "bottomleft",
  legend.title.txt = "Prix nominal \nmoyen (Euros)",
  legend.border = "#B5D0D0")

# Habillage de la carte
layoutLayer(title = "Prix nominal moyen des mutations par commune en Bretagne (2014-2019)", source = "         IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.7, pos = 3, font = 4, offset = 0)
```

### Export des communes enrichies et des départements bretons au format geopackage (pour une utilisation dans un SIG par exemple)

```{r export gpkg 2, eval = FALSE, message = FALSE, warning=FALSE}
st_write(Communes, "CommunesBZHDVF.gpkg", append = FALSE)
st_write(depBZH, "DepartementsBZH.gpkg", append = FALSE)
```

### Partitionnement régulier de l'espace et calcul du prix moyen au m² dans ce découpage

#### Création d'un carroyage avec des mailles de 2 km de côté

```{r carroyage}
grille <- st_make_grid(
  Communes,
  cellsize = 2000, 
  crs = 2154,
  what = "polygons",
  square = TRUE)

# Création d'un identifiant unique par maille
grille <- st_as_sf(grille)
grille <- grille %>% mutate(IDOK = row_number())
plot(st_geometry(grille), border = "grey80", lty = 3)
plot(st_geometry(depBZH), lwd = 1, border = "red", add = TRUE)
```

#### Calcul du nombre de mutations et du prix moyen au m² par maille

```{r calcul nb mutations et prix moyen par maille, warning=FALSE, message = FALSE, error=FALSE}
# pour récupérer l'id des mailles sur chaque mutation
DVFgeobis <- st_join(DVFgeo, grille["IDOK"]) 

# pour calculer le nombre de mutations et leur prix moyen par maille (package data.table)
setDT(DVFgeobis)  # Convertir votre dataframe en data.table
grille.enrichie <- DVFgeobis[, .(Nb_Mutations = .N, 
                                 prixm2moyen = round(mean(prixm2))), 
                             by = IDOK]

# jointure attributaire pour récupérer les résultats dans la grille sf
grillem2 <- merge(grille, grille.enrichie, by = "IDOK", all = TRUE) 
rm(DVFgeobis, grille.enrichie)
```

#### Carte du prix au m² moyen de l'immobilier par maille de 2km

```{r Carte du prix au m2 moyen de immobilier par maille}
# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 0))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = NA, xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

choroLayer(
  x = grillem2, 
  var = "prixm2moyen", 
  breaks = c(300, 1000, 1500, 2000, 2500, 5000),
  col = c("#1a9641", "#a6d96a", "#ffffbf", "#fdae61", "#d7191c"),
  lwd = 0.001,
  add = TRUE,
  legend.nodata = "Aucune mutation",
  colNA = NA,
  border = NA,
  legend.pos = "bottomleft",
  legend.title.txt = "Prix moyen \nau m² (Euros)",
  legend.border = "#B5D0D0")

# Habillage de la carte
layoutLayer(title = "Prix moyen au m² des mutations par maille de 2 km en Bretagne (2014-2019)", source = "         IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "grey50", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.7, pos = 3, font = 4, offset = 0)
```

### Export du carroyage au format geopackage

```{r export gpkg 3, echo=TRUE, message=FALSE, warning=FALSE}
st_write(grillem2, "grillem2.gpkg", append = FALSE) # pour une utilisation dans un SIG par exemple
```

## Lissage spatial

### Lissage spatial des prix de l'immobilier au m² calculés à partir des valeurs agrégées par commune

#### Calcul des distances au plus proche voisin et de l'auto-corrélation spatiale des prix au m²

```{r calcul dist ppv et autocorrelation spatiale 1, warning = FALSE}
# pour calculer les pseudo-centroides des communes (indispensable pour le calcul sur les plus proches voisins)
CommunesBZHDVFCentroids <- st_point_on_surface(Communes)

# Identification du plus proche voisin de chaque commune
listPPV <- knearneigh(CommunesBZHDVFCentroids, k = 1) # pour connaître le plus proche voisin de chaque commune
PPV <- knn2nb(listPPV, row.names = CommunesBZHDVFCentroids$INSEE_COM) # pour convertir l'objet knn en objet nb
distPPV <- nbdists(PPV, CommunesBZHDVFCentroids) # pour connaître la distance entre plus proches voisins

# Pour afficher un résumé statistique et l'histogramme des distances au plus proche voisin
print(as.data.frame(t(as.matrix(summary(unlist(distPPV))))))
hist(unlist(distPPV), breaks = 20,
     main = "Distance au plus proche voisin",
     col = "black", border = "white", xlab = "Distance", ylab = "Fréquence")

# pour convertir les communes en objet nb
nbCom <- poly2nb(pl = Communes,
                 snap = 50,
                 queen = TRUE)

# pour identifier les communes sans voisins topologiques (regions with no links), c'est-à-dire les îles
summary(nbCom)

# création d'une liste des communes sans voisins qui correspondent aux îles (à partir de l'id des lignes)
Iles <- c("14", "427", "488", "1020", "1036", "1037", "1038", "1039")

# suppression des îles sans quoi le calcul de l'indice de Moran n'est pas possible
CommunesBZHDVF <- Communes[which(!row.names(Communes) %in% Iles), ]

# pour reconvertir les communes (sans les îles) en objet nb
nbCom <- poly2nb(pl = CommunesBZHDVF,
                 snap = 50,
                 queen = TRUE)

#calcul du test de Moran
print(moran.test(CommunesBZHDVF$Prixm2Moyen, listw = nb2listw(nbCom)))
```

#### Calcul du semi-variogramme empirique des prix au m² pour déterminer le rayon de lissage

```{r semi-variogramme, warning = FALSE}
# pour calculer les pseudo-centroides des communes sans les îles (indispensable pour le calcul du semi-variogramme)
CommunesBZHDVFCentroids <- st_point_on_surface(CommunesBZHDVF)

# Extraction des coordonnées spatiales
coordinates <- st_coordinates(CommunesBZHDVFCentroids)

# pour créer un dataframe avec la structure attendue par le package geoR
CommunesBZHDVFCentroids.df <- data.frame(x = coordinates[, 1], y = coordinates[, 2], value = CommunesBZHDVFCentroids$Prixm2Moyen)

# pour convertir l'objet sf en objet geodata (format requis par le package geoR pour calculer le semi-variogramme)
CommunesBZHDVFCentroids.geodata <- as.geodata(CommunesBZHDVFCentroids.df)

# pour calculer le semi-variogramme empirique
vario.ex<- variog(CommunesBZHDVFCentroids.geodata, bin.cloud=TRUE, option = "bin")
plot(vario.ex, main = "Semi-variogramme du prix au m² de l'immobilier en fonction de la distance", cex.main = 1)
lines(vario.ex, type ="l", lty = 2, col="red")
```

#### Carte lissée des prix de l'immobilier au m² calculés à partir des valeurs agrégées par commune sur l'ensemble de la Bretagne

```{r Carte lissee des prix m2 agreges par commune, message=FALSE, warning=FALSE}
# pour définir le contour de la Bretagne comme emprise pour le lissage (sinon le lissage est calculé sur une fenêtre rectangulaire)
Emprise <- as.owin(st_geometry(CommunesBZHDVF))

# pour créer un objet ppp (format spatstat) et y intégrer dedans l'emprise et les valeurs à lisser (prix moyen au m²)
CommunesBZHDVF.ppp <- ppp(x = coordinates[, 1], y = coordinates[, 2], window = Emprise, marks = CommunesBZHDVFCentroids$Prixm2Moyen)

# pour calculer la surface lissée (rayon lissage : 5 km et résolution spatiale de l'image : 10 ha) --> calcul long
cartelissee <- Smooth(CommunesBZHDVF.ppp, sigma = 5000, weights = CommunesBZHDVF.ppp$marks, eps = sqrt(100000))

# Conversion de la surface lissée au format raster et spécification du SRC
cartelissee.raster <- terra::rast(cartelissee)
crs(cartelissee.raster) <- st_crs(Communes)$srid

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 2))

# pour afficher la surface lissée et définir l'habillage
# Calcul des seuils
bks <- unique(getBreaks(values(cartelissee.raster), method = "q6"))

# Création d'une palette de couleurs (double gradation harmonique)
cols <- c("#2a9c4e", "#77c35c", "#c4e687", "#ffffc0", "#fec981", "#dc292c")

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Affichage de la surface lissée
plot(cartelissee.raster, breaks = bks, col = cols, add = T, legend = F)
plot(departements$geometry, border = "grey", lwd = 0.05, lty = 3, add = T)
legendChoro(
  pos = "bottomleft",
  title.txt = "Prix moyen au m²",
  breaks = bks, 
  nodata = FALSE,
  values.rnd = -1,
  col = cols
)

# Habillage de la carte
layoutLayer(title = "Prix moyen au m² de l'immobilier par commune en Bretagne entre 2014 et 2019", 
            author = "                          Sources : IGN et DGFip", scale = 20, frame = TRUE, tabtitle = TRUE, col = "#cdd2d4", coltitle = "#8A5543", north = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.7, pos = 2, font = 4, offset = 0)
```

### Lissage spatial des prix de l'immobilier au m² calculés directement à partir des mutations immobilières

#### Calcul des distances au plus proche voisin et de l'auto-corrélation spatiale des prix au m²

```{r calcul dist ppv et autocorrelation spatiale 2, eval=FALSE, warning=FALSE}
# Identification du plus proche voisin de chaque mutation  --> calcul TRES TRES long
listPPV <- knearneigh(DVFgeo, k = 1) # pour connaître le plus proche voisin de chaque mutation
PPV <- knn2nb(listPPV, row.names = DVFgeo$id) # pour convertir l'objet knn en objet nb
distPPV <- nbdists(PPV, DVFgeo) # pour connaître la distance entre plus proches voisins

# Pour afficher un résumé statistique et l'histogramme des distances au plus proche voisin
print(as.data.frame(t(as.matrix(summary(unlist(distPPV))))))
hist(unlist(distPPV), nclass = 500,
     main = "Distance au plus proche voisin",
     col = "black", border = "white", xlab = "Distance", ylab = "Fréquence", xlim = c(0,600))

#calcul du test de Moran
print(moran.test(DVFgeo$prixm2, listw = nb2listw(PPV)))
```

#### Carte lissée des prix de l'immobilier au m² calculés directement à partir des mutations immobilières sur l'ensemble de la Bretagne

```{r carte lissee calculee a partir mutations, message=FALSE, warning=FALSE}
# pour définir le contour de la Bretagne comme emprise pour le lissage (sinon le lissage est calculé sur une fenêtre rectangulaire)
Emprise <- as.owin(st_geometry(CommunesBZHDVF))

# Extraction des coordonnées spatiales
coordinates <- st_coordinates(DVFgeo)

# pour creer un objet ppp (format spatstat) et y intégrer dedans l'emprise et les valeurs à lisser (prix moyen au m²)
MutationsBZHsp.ppp <- ppp(x = coordinates[, 1], y = coordinates[, 2], window = Emprise, marks = DVFgeo$prixm2)

# pour calculer la surface lissée (rayon lissage : 2 km et resolution spatiale de l'image : 10 ha) --> calcul long
cartelissee2 <- Smooth(MutationsBZHsp.ppp, sigma = 2000, weights = MutationsBZHsp.ppp$marks, eps = sqrt(100000))

# Conversion de la surface lissée au format raster
cartelissee.raster2 <- terra::rast(cartelissee2)
crs(cartelissee.raster2) <- st_crs(Communes)$srid

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 2))

# pour afficher la surface lissée et définir l'habillage de la carte
# Calcul des seuils
bks2 <- unique(getBreaks(values(cartelissee.raster2), method = "q6"))

# Création d'une palette de couleurs (double gradation harmonique)
cols <- c("#2a9c4e", "#77c35c", "#c4e687", "#ffffc0", "#fec981", "#dc292c")

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Affichage de la surface lissée
plot(cartelissee.raster2, breaks = bks2, col = cols, add = T, legend = F)
plot(departements$geometry, border = "grey", lwd = 0.05, lty = 3, add = T)
legendChoro(
  pos = "bottomleft",
  title.txt = "Prix moyen au m²",
  breaks = bks2, 
  nodata = FALSE,
  values.rnd = -1,
  col = cols
)

# Habillage de la carte
layoutLayer(title = "Prix moyen au m² de l'immobilier calculés à partir des mutations en Bretagne entre 2014 et 2019", 
            author = "                          Sources : IGN et DGFip", scale = 20, frame = TRUE, tabtitle = TRUE,
            col = "#cdd2d4", coltitle = "#8A5543", north = TRUE)
# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.7, pos = 2, font = 4, offset = 0)
```

## Cartogramme et lissage spatial

### Création d'un objet correspondant aux EPCI bretons et agrégation des valeurs de l'immobilier

```{r creation EPCI}
# pour créer une couche des EPCI à partir des communes
EPCI.BZH <- Communes %>% group_by(CODE_EPCI) %>% summarize()

# pour récupérer l'id des EPCI sur chaque mutation
DVFgeo.enrichi <- st_join(DVFgeo, EPCI.BZH["CODE_EPCI"])

# pour calculer le nombre de mutations et leur prix moyen par EPCI (package data.table)
setDT(DVFgeo.enrichi)  # Convertir votre dataframe en data.table
EPCI.enrichi <- DVFgeo.enrichi[, .(NbMutations = .N, 
                                   prixm2moyen = round(mean(prixm2))), 
                               by = CODE_EPCI]

# jointure attributaire pour récupérer les résultats dans l'objet sf EPCI
EPCI.BZH <- merge(EPCI.BZH, EPCI.enrichi, by = "CODE_EPCI", all = TRUE) 
rm(DVFgeo.enrichi, EPCI.enrichi)
```

### Création d'un cartogramme avec le nombre de mutations par EPCI

```{r affichage cartogramme simple}
# pour créer un cartogramme suivant le nombre de mutations par EPCI
EPCI.BZH.cartogram <- cartogramR(EPCI.BZH, count = "NbMutations", options = list(center = "point_on_surface"))

# Pour déplacer les noms des étiquettes (nom des quelques communes choisies) en fonction de la deformation utilisee pour construire le cartogramme
Selection_Communes.deplacees <- geom_cartogramR(Selection_Communes, EPCI.BZH.cartogram)

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 3))

# pour afficher le cartogramme
plot(EPCI.BZH.cartogram, border = "grey95")

# Ajouter les étiquettes des communes sélectionnées
labelLayer(Selection_Communes.deplacees, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.05, cex = 0.7, pos = 3, font = 4, offset = 0)
```

### Cartogramme montrant le nombre de mutations et les prix au m² de l'immobilier lissés

```{r deformation et carto surface lissee, eval=FALSE, message=FALSE, warning=FALSE}
# reclassification de la surface lissée préalablement calculée
cartelissee.reclass <- classify(cartelissee.raster2, bks, include.lowest = TRUE, brackets = TRUE)

# vectorisation de la surface reclassée
cartelissee.vecteur <- st_as_sf(as.polygons(cartelissee.reclass))

# Pour rogner légèrement cartelissee.vecteur (-3000 mètres) pour que l'emprise de cet objet soit comprise à l'intérieur de celle du cartogramme (opération à n'effectuer que si la commande suivante ne fonctionne pas)
cartelissee.vecteur <- st_crop(cartelissee.vecteur, ext(as.sf(EPCI.BZH.cartogram))-3000)

# Pour déformer la surface lissée suivant les mêmes paramètres que ceux ayant servi à construire le cartogramme
cartelissee.vecteur.drapee <- geom_cartogramR(cartelissee.vecteur, EPCI.BZH.cartogram)

# pour généraliser les contours de cartelissee.vecteur.drapee (on garde 5% des sommets initiaux)
cartelissee.vecteur.drapee <- ms_simplify(cartelissee.vecteur.drapee, keep = 0.05, keep_shapes = TRUE)

# Paramétrage des marges de la fenêtre pour maximiser l'emprise de la carte
par(mar = c(0, 0, 1.2, 3))

# Affichage de tous les départements en arrière-plan, en centrant la carte sur la région Bretagne
plot(st_geometry(departements), col = "grey90", border = NA, bg = "#B5D0D0", xlim = c(st_bbox(Communes)[1], st_bbox(Communes)[3]), ylim = c(st_bbox(Communes)[2], st_bbox(Communes)[4]))

# Affichage de la surface lissée déformée
typoLayer(
  x = cartelissee.vecteur.drapee,
  var= "lyr.1",
  col = cols,
  lwd = 0.1,
  border = cols,
  legend.pos = "n",
  add = TRUE)

# Habillage de la carte
legendChoro(
  pos = "bottomleft",
  title.txt = "Prix moyen \nau m² (Euros)",
  breaks = bks, 
  nodata = FALSE,
  values.rnd = -1,
  col = cols
)

layoutLayer(title = "Prix au m² et mutations par EPCI en Bretagne (2014-2019)", 
            author = "Sources : IGN et DGFip \nDéformation des EPCI suivant le nombre de mutations", horiz = FALSE, scale = FALSE, frame = TRUE,
            col = "#cdd2d4", coltitle = "#8A5543", 
            north = TRUE, tabtitle = TRUE)

# conversion de l'objet cartogram en objet sf et affichage
EPCI.BZH.cartogram.sf <- as.sf(EPCI.BZH.cartogram)
plot(st_geometry(EPCI.BZH.cartogram.sf), border = "white", lwd = 1, add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes.deplacees, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.6, pos = 3, font = 4, offset = 0)
```

## Elaboration d'une typologie à partir d'indicateurs immobiliers et cartographie des sous-marchés associés

### Création d'un tableau avec les variables à soumettre à la CAH pour chacune des communes

```{r preparation donnees pour CAH}
CommunesDVFClassif1 <- as.data.frame(Communes) %>% select(INSEE_COM, NbMutations, PrixMoyen, Prixm2Moyen)
CommunesDVFClassif1 <- CommunesDVFClassif1 %>% na.omit()
CommunesDVFClassif <- CommunesDVFClassif1 %>% select(NbMutations, PrixMoyen, Prixm2Moyen)
```

### Centrage et réduction des variables

```{r centrage et reduction des variables}
CommunesDVFClassifscale <- scale(CommunesDVFClassif)
```

### Classification

```{r CAH}
CAHCommunes <- agnes(CommunesDVFClassifscale,
                     metric = "euclidean",
                     method = "ward")
```

### Graphiques des gains d'inertie inter-classe

```{r graphiques gains inertie}
sortedHeight<- sort(CAHCommunes$height, decreasing = TRUE)
relHeight<-sortedHeight / sum(sortedHeight)*100
cumHeight<- cumsum(relHeight)
barplot(relHeight[1:30], names.arg = seq(1, 30, 1), col = "black", border = "white", xlab = "Noeuds", ylab = "Part de l'inertie totale (%)")
barplot(cumHeight[1:30], names.arg = seq(1, 30, 1), col = "black", border = "white", xlab = "Nombre de classes", ylab = "Part de l'inertie totale (%)")
```

### Arbre hiérarchique

```{r arbre hierarchique}
dendroCSP <- as.dendrogram(CAHCommunes)
plot(dendroCSP, leaflab = "none")
```

### Partition (en n classes)

```{r partionnement en classes}
clusCSP <- cutree(CAHCommunes, k = 7)
CommunesCluster <- as.data.frame(CommunesDVFClassif1)
CommunesCluster$CLUSIMMO <- factor(clusCSP,
                                   levels = 1:7,
                                   labels = paste("CLUS", 1:7))
```

### Création d'un tableau caractérisant les groupes

```{r tableau synthese}
RecapCAHRegion <- CommunesCluster %>% group_by(CLUSIMMO) %>% summarise(
  Nbcommunes= n(), 
  NbMutationsmoyen = round(mean(NbMutations)), 
  Prixmoyen = round(mean(PrixMoyen)), 
  Prixm2moyen = round(mean(Prixm2Moyen)))
print(RecapCAHRegion)
```

### Graphique des variations à la moyenne

```{r Graphique variations a la moyenne, warning=FALSE, message = FALSE, error=FALSE, echo=FALSE}
SyntheseCAHRegion <- RecapCAHRegion %>% mutate(
  NbmutationBZH = mean(CommunesDVFClassif$NbMutations),
  SurfaceBZH = mean(CommunesDVFClassif$SurfaceMoyenne),
  PrixBZH = mean(CommunesDVFClassif$PrixMoyen),
  Prixm2BZH = mean(CommunesDVFClassif$Prixm2Moyen),
  NbMutations = (NbMutationsmoyen - NbmutationBZH)/NbmutationBZH*100,
  Prix = (Prixmoyen- PrixBZH)/PrixBZH*100,
  Prixm2 = (Prixm2moyen- Prixm2BZH)/Prixm2BZH*100,
)

SyntheseCAHRegion <- SyntheseCAHRegion %>% select(CLUSIMMO, Prix, Prixm2)
gather <- SyntheseCAHRegion %>% gather(key = variable, value = "value", Prix:Prixm2)
ggplot(gather, aes(x = variable, y = value, fill = CLUSIMMO)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(values = c("#416979","#f9c155","#39a699","#FF4136","#FF851B","#2cb1e3", "#1f78b4")) +
  ylab("Variation a la moyenne (%)") +
  theme_bw() +
  theme(legend.position = "none") +
  facet_wrap(~CLUSIMMO, ncol = 1)
```

### Représentation cartographique des classes issues de la CAH

```{r representation carto des classes}
CommunesDVFCAH <- merge(Communes, CommunesCluster, by = "INSEE_COM")
par(mar = c(0,0,0.9,0))
typoLayer(
  x = CommunesDVFCAH,
  var ="CLUSIMMO",
  col = c("#416979","#f9c155","#39a699","#FF4136","#FF851B","#2cb1e3", "#1f78b4"),
  border = "#FFFFFF",
  lwd = 0.01,
  legend.values.order = c("CLUS 1",
                          "CLUS 2",
                          "CLUS 3",
                          "CLUS 4",
                          "CLUS 5",
                          "CLUS 6",
                          "CLUS 7"),
  legend.pos = "bottomleft",
  legend.title.txt = "Typologie")
layoutLayer(title = "Sous-marchés immobiliers issus de la CAH", source = "      IGN et DGFip, 2021", 
            north = TRUE, horiz = FALSE, tabtitle = TRUE,
            frame = FALSE, col = "#cdd2d4", coltitle = "#8A5543")

# Ajout des départements de la région
plot(st_geometry(depBZH), lwd = 1, col = NA, border = "#000000", add = TRUE)

# Ajouter les étiquettes des communes sélectionnées plus haut
labelLayer(Selection_Communes, txt = "NOM_COM", halo = TRUE, bg = "white", r = 0.1, cex = 0.7, pos = 3, font = 4, offset = 0)
```

### Export des communes contenant la typologie issue de la CAH au format geopackage

```{r export commune en gpkg, eval=FALSE, message=FALSE, warning=FALSE}
st_write(CommunesDVFCAH, "CommunesBZHDVF.gpkg", append = FALSE) # pour une utilisation dans un SIG par exemple
```
